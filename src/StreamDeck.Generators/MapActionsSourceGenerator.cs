namespace StreamDeck.Generators
{
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using Microsoft.CodeAnalysis;
    using StreamDeck.Generators.Models;

    /// <summary>
    /// Generates the 'IHost.MapActions' extension method.
    /// </summary>
    internal class MapActionsSourceGenerator
    {
        /// <summary>
        /// The fully qualified name of the IHost interface.
        /// </summary>
        private const string IHOST_FULLY_QUALIFIED_NAME = "global::Microsoft.Extensions.Hosting.IHost";

        /// <summary>
        /// The fully qualified name of the StreamDeckAction class.
        /// </summary>
        private const string STREAM_DECK_ACTION_FULLY_QUALIFIED_NAME = "global::StreamDeck.StreamDeckAction";

        /// <summary>
        /// Generates the extension method 'IHost.MapActions', whereby all possible actions that are decorated with <see cref="ActionAttribute"/>, and can be assigned, are.
        /// </summary>
        /// <param name="context">The <see cref="GeneratorExecutionContext"/>.</param>
        /// <param name="nodes">The nodes that represent the classes with <see cref="ActionAttribute"/>.</param>
        public static void Generate(GeneratorExecutionContext context, IReadOnlyCollection<ActionClassDeclarationSyntax> nodes)
        {
            var actions = new Dictionary<string, ActionClassDeclarationSyntax>();

            using var writer = new IndentedTextWriter(new StringWriter());
            writer.Indent = 2;

            foreach (var node in nodes.Where(CanAutoGenerate))
            {
                if (actions.TryGetValue(node.Action.UUID, out var existingNode))
                {
                    // TODO: report an error, but only when MapActions is called.
                }
                else
                {
                    actions.Add(node.Action.UUID, node);
                    writer.WriteLine($"host.MapAction<{node.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(\"{node.Action.UUID}\");");
                }
            }

            var sourceText = $$"""
                // <auto-generated />

                namespace StreamDeck.Extensions.Hosting
                {
                    public static class GeneratedHostExtensions
                    {
                        public static {{IHOST_FULLY_QUALIFIED_NAME}} MapActions(this {{IHOST_FULLY_QUALIFIED_NAME}} host)
                        {
                            // Auto generated actions from their ActionAttribute.
                            {{writer.InnerWriter}}
                            return host;
                        }
                    }
                }
                """;

            context.AddSource("GeneratedHostExtensions.g", sourceText);
        }

        /// <summary>
        /// Determines whether the specified <paramref name="node"/> is declared by a class that can be mapped to the IHost.
        /// </summary>
        /// <param name="node">The node.</param>
        /// <returns><c>true</c> when the node's symbol can be automatically mapped to an IHost; otherwise <c>false</c>.</returns>
        private static bool CanAutoGenerate(ActionClassDeclarationSyntax node)
        {
            if (node.Symbol is not INamedTypeSymbol namedTypeSymbol)
            {
                return false;
            }

            if (namedTypeSymbol.IsGenericType)
            {
                // TODO: report an error, but only when MapActions is called.
                return false;
            }

            if (namedTypeSymbol.IsAbstract)
            {
                // TODO: report an error, but only when MapActions is called.
                return false;
            }

            while (namedTypeSymbol.BaseType != null)
            {
                if (namedTypeSymbol.BaseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == STREAM_DECK_ACTION_FULLY_QUALIFIED_NAME)
                {
                    return true;
                }

                namedTypeSymbol = namedTypeSymbol.BaseType;
            }

            return false;
        }
    }
}
