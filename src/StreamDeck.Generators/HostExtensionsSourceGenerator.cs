namespace StreamDeck.Generators
{
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using Microsoft.CodeAnalysis;

    /// <summary>
    /// Generates extension methods on 'IHost'.
    /// </summary>
    internal class HostExtensionsSourceGenerator
    {
        /// <summary>
        /// The fully qualified name of Microsoft.Extensions.Hosting.
        /// </summary>
        public const string HOSTING_FULLY_QUALIFIED_NAME = "global::Microsoft.Extensions.Hosting";

        /// <summary>
        /// The fully qualified name of the Microsoft.Extensions.Hosting.IHost interface.
        /// </summary>
        private const string IHOST_FULLY_QUALIFIED_NAME = $"{HOSTING_FULLY_QUALIFIED_NAME}.IHost";

        /// <summary>
        /// The fully qualified name of the StreamDeck.StreamDeckAction class.
        /// </summary>
        private const string STREAM_DECK_ACTION_FULLY_QUALIFIED_NAME = "global::StreamDeck.StreamDeckAction";

        /// <summary>
        /// Generate the extension methods on 'IHost' based on the <see cref="GeneratorExecutionContext"/> and <paramref name="nodes"/>.
        /// </summary>
        /// <param name="context">The <see cref="GeneratorExecutionContext"/>.</param>
        /// <param name="nodes">The nodes that represent the classes with <see cref="ActionAttribute"/>.</param>
        public static void Generate(GeneratorExecutionContext context, IReadOnlyCollection<ActionClassContext> nodes)
        {
            var sourceText = $$"""
                // <auto-generated />

                namespace StreamDeck.Extensions.Hosting
                {
                    using {{HOSTING_FULLY_QUALIFIED_NAME}};

                    public static class GeneratedHostExtensions
                    {
                        /// <summary>
                        /// Maps all actions based on their UUID to the plugin.
                        /// </summary>
                        /// <param name="host">The <see cref="IHost"/> to configure.</param>
                        /// <returns>The same instance of the <see cref="IHost"/> for chaining.</returns>
                        public static {{IHOST_FULLY_QUALIFIED_NAME}} MapActions(this {{IHOST_FULLY_QUALIFIED_NAME}} host)
                        {
                            // Auto generated actions from their ActionAttribute.
                            {{GetMappedActions(nodes)}}
                            return host;
                        }

                        /// <summary>
                        /// Maps all actions based on their UUID, and runs the plugin
                        /// </summary>
                        /// <param name="host">The <see cref="IHost"/> to configure and run.</param>
                        public static void RunPlugin(this {{IHOST_FULLY_QUALIFIED_NAME}} host)
                            => host.MapActions().Run();
                    }
                }
                """;

            context.AddSource("HostExtensions.g", sourceText);
        }

        private static string GetMappedActions(IReadOnlyCollection<ActionClassContext> nodes)
        {
            var actions = new Dictionary<string, ActionClassContext>();

            using var writer = new IndentedTextWriter(new StringWriter());
            writer.Indent = 3;

            foreach (var node in nodes.Where(CanAutoGenerate))
            {
                if (node.UUID == null)
                {
                    continue;
                }

                if (actions.TryGetValue(node.UUID, out var existingNode))
                {
                    // TODO: report an error, but only when MapActions is called.
                }
                else
                {
                    actions.Add(node.UUID, node);
                    writer.WriteLine($"host.MapAction<{node.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(\"{node.UUID}\");");
                }
            }

            return writer.InnerWriter.ToString();
        }

        /// <summary>
        /// Determines whether the specified <paramref name="node"/> is declared by a class that can be mapped to the IHost.
        /// </summary>
        /// <param name="node">The node.</param>
        /// <returns><c>true</c> when the node's symbol can be automatically mapped to an IHost; otherwise <c>false</c>.</returns>
        private static bool CanAutoGenerate(ActionClassContext node)
        {
            if (node.Symbol.IsGenericType)
            {
                // TODO: report an error, but only when MapActions is called.
                return false;
            }

            if (node.Symbol.IsAbstract)
            {
                // TODO: report an error, but only when MapActions is called.
                return false;
            }

            var baseType = node.Symbol.BaseType;
            while (baseType != null)
            {
                if (baseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == STREAM_DECK_ACTION_FULLY_QUALIFIED_NAME)
                {
                    return true;
                }

                baseType = baseType.BaseType;
            }

            return false;
        }
    }
}
